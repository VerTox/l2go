package loginserver

import (
  "fmt"
  "net"
  "os"
  "crypto/rand"
  "crypto/rsa"
  "github.com/frostwind/l2go/packet"
)

func handleConnection(conn net.Conn, modulus []byte, key *rsa.PrivateKey) {

  // Create the packet wrapper
  packet_c := []byte{0x00,
    0xfd, 0x8a, 0x22, 0x00, 0x5a, 0x78, 0x00, 0x00, // Header : Session id and Protocol revision 0x785a
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // Fake RSA key modulus
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Unknown
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

  // Inject our modulus
  for i := 0; i < len(modulus); i++ {
    packet_c[9 + i] = modulus[i]
  }

  length := len(packet_c) + 2
  buffer := make([]byte, length)

  buffer[0] = byte(length & 0xff)
  buffer[1] = byte((length >> 8) & 0xff)
  copy(buffer[2:], packet_c)

  fmt.Println("A client is trying to connect...")
  fmt.Printf("Created a an init packet[%d] = %X\n", len(buffer), buffer)

  fmt.Println("Sending the Init packet...")
  conn.Write([]byte(buffer))

  fmt.Println("Receiving the Init response")
  for {
    received := make([]byte, 65537)

    _, _ = conn.Read(received)

    fmt.Println("Decryption ..")
    _, _ = packet.Decrypt(received)
  }

}
func generateRSA() ([]byte, *rsa.PrivateKey) {
  privatekey, err := rsa.GenerateKey(rand.Reader, 1024)

  if err != nil {
   fmt.Println(err.Error)
   os.Exit(1)
  }

  var publickey *rsa.PublicKey
  publickey = &privatekey.PublicKey
  scrambledModulus := publickey.N.Bytes() // modulus to bytes

  for i := 0; i < 4; i++ {
    temp := scrambledModulus[0x00+i]
    scrambledModulus[0x00+i] = scrambledModulus[0x4d+i]
    scrambledModulus[0x4d+i] = temp
  }

  // step 2 xor first 0x40 bytes with last 0x40 bytes
  for i := 0; i < 0x40; i++ {
      scrambledModulus[i] = byte(scrambledModulus[i] ^ scrambledModulus[0x40+i])
  }

  // step 3 xor bytes 0x0d-0x10 with bytes 0x34-0x38
  for i := 0; i < 4; i++ {
      scrambledModulus[0x0d+i] = byte(scrambledModulus[0x0d+i] ^ scrambledModulus[0x34+i])
  }

  // step 4 xor last 0x40 bytes with first 0x40 bytes
  for i := 0; i < 0x40; i++ {
      scrambledModulus[0x40+i] = byte(scrambledModulus[0x40+i] ^ scrambledModulus[i])
  }

  return scrambledModulus, privatekey
}

func Init() {
  modulus, key := generateRSA()
  fmt.Println("Testing the first packet :")
  r := []byte{0x32,0x00,0xB3,0xFC,0x1E,0xDA,0x56,0xFC,0x70,0xD5,0x88,0x44,0x98,0x37,0xBD,0x80,0xDF,0x9A,0x88,0x7C,0x29,0x0F,0xBE,0x52,0xB3,0x1F,0x0D,0x2D,0x41,0x44,0x78,0x22,0x29,0xB6,0x76,0x62,0x4A,0x79,0xFE,0x01,0xED,0x06,0x87,0x2A,0xA9,0x4F,0x56,0x52,0xCE,0xE3}
  _, _ = packet.Decrypt(r)

  fmt.Println("\n\n\n\n")

  fmt.Println("Testing the second packet :")
  r2 := []byte{0x32, 0x00, 0x27,0x51,0x74,0x4c,0x30,0xea,0x12,0x61,0xef,0x53,0xbe,0xbd,0xd1,0x9b,0xc1,0xb7,0x48,0x95,0x41,0xbf,0xfe,0xae,0xb7,0x02,0xbf,0x31,0xa7,0xa9,0x80,0xc1,0x35, 0x5c,0xbd,0xb3,0xc2,0x8c,0xb2,0x4b,0x87,0x7b,0xf3,0x3c,0x4f,0xdb,0x95,0xa4,0x02,0x30}
  _, _ = packet.Decrypt(r2)

  ln, err := net.Listen("tcp", ":2106")
  defer ln.Close()

  if err != nil {
    fmt.Println("Couldn't initialize the Login Server")
  } else {
    fmt.Println("Login Server initialized.")
    fmt.Println("Listening on 127.0.0.1:2106.")
  }

  for {
    conn, err := ln.Accept()
    if err != nil {
      fmt.Println("Couldn't accept the incoming connection.")
      continue
    }

    go handleConnection(conn, modulus, key)
  }
}
